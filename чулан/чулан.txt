					duplicate: "Такое имя уже занято. " +
						"Попробуйте добавить к нему какую-нибудь подробность о себе. " +
						"Например, «Василий» → «Василий (музыкант)»" + 
						"Например, «Иван Иванович» → «Иван Иванович из Москвы»" +
						"Например, «Кот» → «Кот, который гуляет сам по себе»"
						
/*
var previous_arrow
var next_arrow

var dont_animate = false

// activate arrows
function initialize_arrows()
{
	// previous
	previous_arrow = new image_button
	(
		"previous_person_button", 
		{
			path: "/картинки/на страницах/people/button",
			"button name": "previous",
			width: 64,
			height: 64,
			action: function() { people.previous() }
		}
	)
	
	// next
	next_arrow = new image_button
	(
		"next_person_button", 
		{
			path: "/картинки/на страницах/people/button",
			"button name": "next",
			width: 64,
			height: 64,
			action: function() { people.next() }
		}
	)
}

function refresh_arrows()
{
	// previous
	if (people.has_previous())
	{
		if (!dont_animate)
			previous_arrow.show()
		else
			previous_arrow.show_animated()
	}
	else
	{
		if (!dont_animate)
			previous_arrow.hide()
		else
			previous_arrow.hide_animated()
	}
	
	// next
	if (people.has_next())
	{
		if (!dont_animate)
			next_arrow.show()
		else
			next_arrow.show_animated()
	}
	else
	{
		if (!dont_animate)
			next_arrow.hide()
		else
			next_arrow.hide_animated()
	}
}
*/



function initialize_page()
{
//	initialize_arrows()
	
//	dont_animate = true
//	refresh_arrows()
//	dont_animate = false
}






		
				<!-- IP address detection
		<script type="text/javascript">
			function detect_ip(data)
			{
				console.log(data.ip)

				var query = 		
						
				"<ipquery>" +
					"<fields>" +
						"<city/>" +
					"</fields>" +
					"<ip-list>" +
						"<ip>" + data.ip + "</ip>" +
					"</ip-list>" +
				"</ipquery>"
				
				// ajax POST
				$.ajax
				({
					url: 'http://ipgeobase.ru:8090/geo/geo.html', 
					type: 'POST',
					data: query, 
					success: function(text, textStatus)
					{
						alert(text)
					},
					error: function(XMLHttpRequest, textStatus, errorThrown)
					{
						alert("error " + errorThrown)
					},
					dataType: 'text',
					timeout: 1000
				})
			}
		</script>

		<!-- IP address detection service
		<script type="application/javascript" src="http://jsonip.appspot.com/?callback=detect_ip"></script>
		 -->
		 
		
		
		
		
		
		
		
		
		
/*
var connect = require('connect');

connect(
  connect.static(require('path').join(__dirname, '../..'))
).listen(8080, '0.0.0.0');
*/

/*
var http = require('http');
http.createServer(function (req, res) {
  res.writeHead(200, {'Content-Type': 'text/plain'});
  res.end(decodeURI(req.url) + '\n');
}).listen(1337, "127.0.0.1");
console.log('Server running at http://127.0.0.1:1337/');
*/









module.exports = () ->
	цепь = выполнить()
		
	цепь.дальше = (inner_callback) ->
		(ошибка) ->
			console.log 'error occured: '
			
			if ошибка?
				цепь.ошибка = ошибка

			console.log цепь.ошибка

			inner_callback.apply(null, arguments)
		
	старый_catch = цепь.catch
	цепь.catch = (обработчик) ->
		console.log 'проверка ошибки: '
		console.log цепь.ошибка

		if not цепь.ошибка?
			return старый_catch(обработчик)
		
		console.log 'error: '
		console.log цепь.ошибка
			
		обработчик(цепь.ошибка)
		цепь.ошибка = null
		
		fake = {}
		['seq', 'par', 'parEach', 'catch'].forEach (method) ->
			fake[method] = () ->
		fake
		
	цепь
	
	
	
	
	
	
	
	
	
	
	
	
	
	

	###
	# не работает, т.к. у меня Node.js не находит utf-8 файлы на диске (на винде)
	# в будущем ответ этот - класть в memcache, и брать оттуда nginx'ом минуя node.js
	.seq ->
		this null, [ 
			пути.join(process.cwd(), "ресурсы/страницы/основа.html"), 
			пути.join(process.cwd(), "ресурсы/страницы/#{название}.html") 
		]
		
	.flatten()
	
	.parEach (путь_к_файлу) ->
	
		пути.exists путь_к_файлу, (exists) =>
			if not exists
				this "Файл #{путь_к_файлу} не найден"
				return
				
			this null, путь_к_файлу
		
	.catch (ошибка) ->
		console.error ошибка
		вывод.send ошибка: ошибка
		break: true
		
	.seq (путь_к_основе, путь_к_содержимому_страницы) ->
		[путь_к_основе, путь_к_содержимому_страницы]
		
	.flatten()
	
	.parEach (путь_к_файлу) ->
		disk readFile путь_к_файлу, 'utf-8', this
	###
	
	
	
	
	
	
	
	
	
Connect: v 1.x
там ещё в middleware/cookie.js нужно в set maxAge написать "new Date(Date.now().getTime() + ms)"
иначе сессионности не будет












		
		/*
		// box shadow plugin doesn't support multiple shadows
		
		var author = $(this)
		if (author.attr('online') == true)
			return
			
		var picture = author.find('.picture')
			
		var dummy = $('<div/>')
		dummy.addClass('online')
		dummy.addClass('author')
		dummy.hide()
		
		var picture_dummy = $('<div/>')
		picture_dummy.addClass('picture')
		picture_dummy.appendTo(dummy)
		
		author.after(dummy)
		
		picture.animate({ 'boxShadow': picture_dummy.css('box-shadow') })
		*/
		
		
вставка формул TeX:
http://texify.com/img/%5CLARGE%5C!tex
http://chart.apis.google.com/chart?cht=tx&chl=\displaystyle\int_{-\infty}^{\infty}e^{-x^{2}}\;dx=\sqrt{\pi.gif











	
	for_jsdom =
		html: '<pre>' + html + '</pre>',
		src: [jQuery],
		done: (errors, window) ->
			if (errors)
				return возврат(errors)
				
			$ = window.$
					
			$('script').remove()
		
			remove_attributes = [
				'onblur'
				'onchange'
				'onclick'
				'ondblclick'
				'onfocus'
				'onfocusin'
				'onfocusout'
				'onmouseover'
				'onmousemove'
				'onmousedown'
				'onmouseup'
				'onkeydown'
				'onkeyup'
				'onkeypress'
				'onresize'
				'onscroll'
				'onselect'
				'onsubmit'
				'onreset'
				'onload'
				'onunload'
			]
		
			for attribute in remove_attributes
				$('*').removeAttr(attribute)
				
			console.log($('pre:first').html())
			возврат(null, $('pre:first').html())
			
	jsdom.env(for_jsdom)
	
	
	
# это временно
	
jsdom  = require 'jsdom'
jQuery = require('fs').readFileSync(process.cwd() + '/code/web/tools/jquery.js').toString()

	
	

/**
 * disables page scrolling
 */

/*
var namespace = 'main'

function disable_scroll()
{
	$(window).on('scroll.' + namespace, {scroll_position: get_scroll_position()}, function(event) 
	{
		window.scrollTo(event.data.scroll_position.x, event.data.scroll_position.y)
    	return false
	})
}
*/

/**
 * enables page scrolling
function enable_scroll()
{
	$(window).unbind('scroll.' + namespace)
}
 */







			#connections = карта_соединений_по_виду_сообщения(group, name)


				###
				for id, connection of connections
					if connection.пользователь?
						if connection.пользователь._id + '' == _id + ''
							user_connections.push(connection)
				
				for connection in user_connections
					if options._id? && connection.custom_data? && connection.custom_data._id?
						if connection.custom_data._id != options._id
							continue
					connection.emit(group + ':' + name, data)
					return @.done(yes)
				
				connections = соединения.эфир
				###
				
				
								###
				for id, connection of connections
					if connection.пользователь?
						user_id = connection.пользователь._id + ''
						if user_id != options.кроме + ''
							if not users_connections[user_id]?
								users_connections[user_id] = []
							users_connections[user_id].push(connection)
				
				for user_id, user_connections of users_connections
					for connection in user_connections
						if options._id? && connection.custom_data? && connection.custom_data._id?
							if connection.custom_data._id != options._id
								continue
						connection.emit(group + ':' + name, data)
						notified_users[user_id] = yes
						break
					
				connections = соединения.эфир
				###
						




# проверить занятость путей
		
		.сделать ->
			if надраздел?
				return db('library_paths').findOne({ раздел: надраздел }, @.в 'путь_к_надразделу')
			@.done()
			
		.сделать ->
			@.done(разделы.новые)
			
		.все_вместе (раздел) ->
			раздел.путь = снасти.escape_id(раздел.название)
			
			if надраздел?
				раздел.путь = @.$.путь_к_надразделу.путь + '/' + раздел.путь
				
			db('library_paths').findOne({ путь: раздел.путь }, @)
			
		.сделать (пути_к_разделам) ->
			if not пути_к_разделам.пусто()
				return @.error('Такой путь к разделу уже занят: ' + пути_к_разделам[0].путь)
			@.done()
			
			
			
			
			
			
			
			
			
			
			
			
			
		# проверить удаление непустых разделов
		
		.сделать ->
			@.done(разделы.удалённые)
			
		.все_вместе (раздел) ->
			db('library_categories').findOne({ _id: db('library_categories').id(раздел) }, @)

		.сделать (разделы) ->
			@._.удаляемые_разделы = разделы
			
			for раздел in разделы
				if раздел.надраздел?
					return @.error('Удаляемый раздел «' + раздел.название + '» не пустой (содержит подразделы). На данное время возможно только удаление пустых разделов (не рекурсивное). Сначала опустошите удаляемый раздел.')
			@.done(разделы)
		
		.все_вместе (раздел) ->
			db('library_articles').findOne({ раздел: раздел._id }, @)

		.сделать (заметки) ->
			if not заметки.пусто()
				заметка = заметки[0]
				for раздел in @._.удаляемые_разделы
					if раздел._id + '' == заметка.раздел + ''
						return @.error('Удаляемый раздел «' + раздел.название + '» не пустой (содержит заметки). На данное время возможно только удаление пустых разделов (не рекурсивное). Сначала опустошите удаляемый раздел.')
				return @.error()
			@.done(разделы)
			
			
			
			
			
			
			
			
			
			
			
			

http.get "/сеть/читальня/заметка/версия", (ввод, вывод, пользователь) ->
	цепь(вывод)
		.сделать ->
			db('library_articles').findOne({ _id: _id }, @)
			
		.сделать (заметка) ->
			вывод.send(версия: заметка.версия)
			
			
			
			
			
			
			
			
			
			
			
			
		
		/* can be deleted */
		&.test
		{
			height: 50px;
			
			border-width: 1px;
			border-color: black;
			border-style: solid;
			
			margin: 0;
			
			box-sizing: border-box;
		}
		
		
		
		
		
		
		
		
		

Object.merge = function(obj1, obj2)
{
	for (var key in obj2)
	{
		if obj2.hasOwnProperty(key)
		{
			if (typeof obj2[key] === 'object' && obj1[key])
				obj1[key] = Object.merge_recursive(obj1[key], obj2[key])
			else
				obj1[key] = obj2[key]
		}
	}
	
	return obj1
}

Object.x_over_y = function(obj1, obj2)
{
	if (!obj1)
		return obj2
	
	return Object.merge_recursive(obj2, obj1)
}







		<h1>Что будет удерживать здесь пользователей ежедневно?</h1>
		
		<p>В <a href="/сеть/болталка">Болталке</a> всегда можно будет пообщаться на отвлечённые темы, пока вы сидите на работе, или «отходите» вечером после работы. Если у вас есть какие-то интересные мысли, или вопрос, ответ на который не «гуглится», вы можете создать тему в <a href="/сеть/обсуждения">Обсуждениях</a>. Вы можете общаться в <a href="/сеть/беседы">Беседах</a> со своими друзьями (вдвоём, втроём, вчетвером, ...).</p>
		<p>Если у вас уже есть своё небольшое сообщество, со своей базой знаний, вы можете присоединиться к нам. Вы сможете, как и раньше, общаться друг с другом в <a href="/сеть/беседы">Беседах</a>, и создать в <a href="/читальня">Читальне</a> свой раздел, куда сможете перенести всю свою базу знаний. Вы всегда сможете сохранить эту базу знаний в PDF и RTF, так что если с нашей сетью вдруг что-то случится, то ваши труды останутся с вами.</p>

		
		
		
		
		
		
		
		
		
							'дневник': function(rest)
							{
								название_страницы = 'человек/дневник'
								
								match_url(rest,
								{
									'*': function(value, rest)
									{
										название_страницы = 'человек/запись в дневнике'
										new_page.data.запись = value
									}
								})
							},
							'журнал': function(rest)
							{
								название_страницы = 'человек/журнал'
								
								match_url(rest,
								{
									'*': function(value, rest)
									{
										название_страницы = 'человек/запись в журнале'
										new_page.data.запись = value
									}
								})
							},