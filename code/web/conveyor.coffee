class Цепь
	constructor: ->
		@действия = []
		
		process.nextTick =>
			@дальше()
			
	возврат: (ошибка) =>
		if ошибка?
			ловушка = @найти_ловушку()
			if ловушка?
				return ловушка.алгоритм ошибка
			console.error "Error:"
			return console.error ошибка
		
		переменные = [].slice.call(arguments, 1);
		if not @накапливать()
			return @дальше(переменные)
		переменные.forEach (переменная) ->
			@переменные << переменная
		@сколько_накапливать--
		
		if not @накапливать()
			return @дальше(@переменные)
		
	накапливать: ->
		@сколько_накапливать > 0
	
	дальше: (переменные) ->
		if @действия.is_empty()
			return
		действие = @действия.shift()
		switch действие.вид
			when 'последовательно'
				действие.алгоритм.apply(null, переменные)
			when 'каждый одновременно'
				@сколько_накапливать = переменные.length
				переменные.forEach (переменная) ->
					действие.алгоритм.call(null, переменная)
			when 'каждый последовательно'
				throw 'not implemented'
			when 'ошибка'
				@дальше переменные
		
	найти_ловушку: ->
		ловушка = null
		@действия.forEach (действие) ->
			if not ловушка?
				if действие.вид == 'ошибка'
					ловушка = действие
		ловушка
	
	ошибка: (обработчик) ->
		@действия.push { алгоритм: обработчик, вид: 'ошибка' }
		@
		
	сделать: (что) ->
		@действия.push { алгоритм: что.bind(@возврат), вид: 'последовательно' }
		@

	все_вместе: (что) ->
		@действия.push { алгоритм: что.bind(@возврат), вид: 'каждый одновременно' }
		@

	каждый: (что) ->
		@действия.push { алгоритм: что.bind(@возврат), вид: 'каждый последовательно' }
		@

#for действие, алгоритм of действия
#	цепь.prototype[действие] = алгоритм

module.exports = -> new Цепь