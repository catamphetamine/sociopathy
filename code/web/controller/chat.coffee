#sanitize = require('validator').sanitize

# redis clients
#store = redis.createClient()
#publisher = redis.createClient()
#subscriber = redis.createClient()
online = redis.createClient()

хранилище.bind 'chat',
	выбрать: (настройки, возврат) ->
		условия = настройки.условия || {}
		дополнительно = { skip: настройки.с - 1, limit: настройки.сколько }
		дополнительно.sort = настройки.sort
		@find(условия, дополнительно).toArray возврат

#subscriber.subscribe("chat")
		
болталка = websocket
	.of('/болталка')
	.on 'connection', (соединение) ->
		соединение.on 'пользователь', (тайный_ключ) ->
			пользователь = null
			цепь_websocket(соединение)
				.сделать ->
					пользовательское.опознать(тайный_ключ, @.в 'пользователь')
				
				.сделать (user) ->
					if not user?
						return send ошибка: 'пользователь не найден: ' + тайный_ключ
					пользователь = user
					@()
					
				.сделать () ->
					online.hset('chat:online', пользователь._id.toString(), JSON.stringify(пользователь), @)
				
				.сделать () ->
					online.hgetall('chat:online', @)
					
				.сделать (who_is_online) ->
					who_is_online_info = []
					for id, json of who_is_online
						if id + '' != пользователь._id + ''
							who_is_online_info.push(JSON.parse(json))
							
					соединение.emit 'online', who_is_online_info
					соединение.broadcast.emit('user_online', пользовательское.выбрать_поля(['адресное имя', 'имя', '_id', 'пол'], пользователь))
					соединение.emit 'готов'
			
			соединение.on 'смотрит', (сообщение) ->
				соединение.broadcast.emit('смотрит', пользовательское.выбрать_поля(['_id'], пользователь))
					
			соединение.on 'не смотрит', (сообщение) ->
				соединение.broadcast.emit('не смотрит', пользовательское.выбрать_поля(['_id'], пользователь))
			
			соединение.on 'сообщение', (сообщение) ->
				сообщение = сообщение.escape_html()
				#сообщение = sanitize(сообщение).xss()
				#время = снасти.сейчас({ минуты: yes })
				
				цепь_websocket(соединение)
					.сделать () ->
						хранилище.collection('chat').save { 'отправитель': пользователь._id, 'сообщение': сообщение, 'время': new Date() }, @
						
					.сделать (сообщение) ->
						ввод.session.data['последнее сообщение в болталке'] = сообщение._id
						данные_сообщения =
						{
							отправитель: пользовательское.выбрать_поля(['адресное имя', 'имя', '_id'], пользователь)
							сообщение: сообщение.сообщение
							время: сообщение.время
						}
						
						console.log данные_сообщения
						
						#publisher.publish("chat", "messages:" + id)
						
						#соединение.emit('сообщение', данные_сообщения)
						#соединение.broadcast.emit('сообщение', данные_сообщения)
						болталка.emit('сообщение', данные_сообщения)
		
			соединение.on 'disconnect', () ->
				цепь(websocket)
					.сделать ->
						online.hdel('chat:online', пользователь._id, @)
						
					.сделать () ->
						соединение.broadcast.emit('offline', пользовательское.выбрать_поля(['_id'], пользователь))

Max_batch_size = 1000
						
http.get '/болталка/сообщения', (ввод, вывод) ->
	return if пользовательское.требуется_вход(ввод, вывод)
	
	цепь(вывод)
		.сделать ->
			начиная_с_какого_выбрать(ввод, @)
				
		.сделать (с_какого_выбрать) ->
			выбрать(с_какого_выбрать, ввод.настройки.сколько, ввод, @)
				
		.сделать (сообщения) ->
			вывод.send сообщения

начиная_с_какого_выбрать = (ввод, возврат) ->
	с_какого_выбрать = ввод.session.data['последнее сообщение в болталке']
	return @.done({ с: с_какого_выбрать, ограничение: Max_batch_size }) if с_какого_выбрать?
	
	new Цепочка(возврат)
		.сделать ->
			id = ввод.session.пользователь._id
			хранилище.collection('chat').find({ отправитель: id }, { sort: [['$natural', -1]], limit: 1 }).toArray @
		
		.сделать (сообщения) ->
			сообщение = сообщения[0]
			return @.done({ с: сообщение._id, ограничение: Max_batch_size }) if сообщение?
			хранилище.collection('chat').find({}, { skip: ввод.настройки.сколько - 1, limit: 1, sort: [['$natural', -1]] }).toArray @

		.сделать (сообщения) ->
			сообщение = сообщения[0]
			return @.done({ с: сообщение._id }) if сообщение?
			throw 'no result in с_какого_выбрать'
				
выбрать = (с_какого, сколько, ввод, возврат) ->
	ограничение = с_какого.ограничение
	if not ограничение?
		ограничение = ввод.настройки.сколько

	new Цепочка(возврат)
		.сделать ->
			хранилище.collection('chat').find({ _id: { $gte: с_какого.с } }, { limit: ограничение, sort: [['$natural', -1]] }).toArray @.в 'сообщения'
	
		.все_вместе (сообщение) ->
			хранилище.collection('people').findOne { _id: сообщение.отправитель }, @
	
		.сделать (отправители) ->
			@.переменная('сообщения').forEach (сообщение, индекс) ->
				сообщение.отправитель = пользовательское.выбрать_поля(['имя', 'адресное имя', 'пол', '_id'], отправители[индекс])
			@()
			
		.сделать ->
			хранилище.collection('chat').findOne({ _id: { $gt: @.переменная('сообщения')[0]._id } }, @)
			
		.сделать (не_вместившееся_сообщение) ->
			if не_вместившееся_сообщение?
				есть_ли_ещё = yes
			@.done({ сообщения: @.переменная('сообщения'), 'есть ещё?': есть_ли_ещё })