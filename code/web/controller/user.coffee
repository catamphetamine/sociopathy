# защита от перебора пароля:
#
# когда вход, проверяют "предыдущую неудавшуюся попытку входа"
# если она меньше, чем за час до текущей - ставить "температуру" в 2 раза больше (2, если ноль), и прописывать уже эту дату попытки входа
# если температура больше 1000 - не давать входить.
# каждые 15 минут температура остывает в 2 раза
http.post '/вход', (ввод, вывод) ->
	The_hottest_allowed_temperature = 1000
	Temperature_half_life = 15 # minutes
	Temperature_doubles_when_in_interval = 60 # minutes
	
	цепь(вывод)
		.сделать ->
			пользовательское.взять({ имя: ввод.body.имя }, { полностью: yes }, @._.в 'пользователь')
		
		.сделать (пользователь) ->
			if not пользователь?
				return вывод.send ошибка: 'Такого пользователя нет в нашей сети'
		
			db('people_sessions').findOne({ пользователь: пользователь._id }, @._.в 'session')
			
		.сделать ->
			# насколько успело остыть - настолько остудить
			@._.температура = 0
			if @._.session.последний_неудавшийся_вход?
				@._.температура = @._.session.последний_неудавшийся_вход.температура
				когда = @._.session.последний_неудавшийся_вход.когда
				сейчас = new Date()
				
				while когда.add(Temperature_half_life).minutes().isBefore(сейчас)
					@._.температура /= 2
					когда = когда.add(Temperature_half_life).minutes()
					if @._.температура < 1
						@._.температура = 0
						delete @._.session.последний_неудавшийся_вход
						break
					
			@.done()

		.сделать ->
			if @._.пользователь.пароль != ввод.body.пароль
				@._.не_вошёл = yes
				if @._.температура < The_hottest_allowed_temperature
					if @._.session.последний_неудавшийся_вход?
						if @._.session.последний_неудавшийся_вход.когда.add(Temperature_doubles_when_in_interval).minutes().isAfter(new Date())
								@._.температура *= 2
					else
						@._.температура = 2
						
					return db('people_sessions').update({ пользователь: @._.пользователь._id }, { $set: { последний_неудавшийся_вход: { когда: new Date(), температура: @._.температура } } }, @)
			
			@.done()

		.сделать ->
			if @._.температура >= The_hottest_allowed_temperature
				return вывод.send ошибка: 'Возможно вы пытаетесь взломать пароль. Попробуйте позже.'
				
			if @._.не_вошёл?
				return вывод.send ошибка: 'Неверный пароль'
			
			db('people_sessions').update({ пользователь: @._.пользователь._id }, { $unset: { последний_неудавшийся_вход: yes } }, @)
			
		.сделать ->
			пользовательское.войти(@._.пользователь, ввод, вывод, @)
		
		.сделать ->
			вывод.send(пользователь: пользовательское.поля(@._.пользователь))

http.post '/выход', (ввод, вывод) ->
	пользовательское.выйти ввод, вывод
	вывод.send {}
	
http.put '/прописать', (ввод, вывод) ->
	цепь(вывод)
		.сделать ->
			настройки =
				query:
					ключ: ввод.body.приглашение,
					использовано:  { $exists : no } 
					
			options =
				#remove: yes
				update: { $set: { использовано: yes } }
			
			db('invites').findAndModify настройки, [], {}, options, @
			
		.сделать ->
			@._.человек = ввод.body
			
			@._.человек['когда пришёл'] = new Date()
			@._.человек['адресное имя'] = снасти.сделать_id(@._.человек.имя)
			#@._.человек.почта = @._.человек.имя + '@sobranie.net'
			
		#	снасти.hash(@._.человек.пароль, @)
			
		#.сделать (hash) ->
		#	@._.человек.пароль = hash
		
			пользовательское.создать(@._.человек, @._.в 'пользователь')
	
		.сделать (пользователь) ->
			@.done(пользовательское.сделать_тайный_ключ(пользователь))
			
		.сделать (тайный_ключ) ->
			db('people_private_keys').save { пользователь: @._.пользователь._id, 'тайный ключ': тайный_ключ }, @

		.сделать ->
			db('circles').save({ пользователь: человек._id, круг: 'Основной', члены: [] }, @)

		.сделать ->
			db('people_sessions').save({ пользователь: человек._id }, новости: { беседы: {}, обсуждения: {}, новости: [] })

		.сделать ->
			db('news').save({ что: 'прописка', пользователь: человек._id, когда: new Date() })
			
		.сделать ->
			вывод.send ключ: @._.пользователь._id

http.get '/приглашение/проверить', (ввод, вывод) ->
	цепь(вывод)
		.сделать ->
			db('invites').findOne {ключ: ввод.настройки.приглашение.toString() }, @
		
		.сделать (приглашение) ->
			if not приглашение?
				return @.error('Нет такого приглашения в списке')
				
			if приглашение.использовано
				return @.error('Это приглашение уже использовано')
				
			вывод.send приглашение: приглашение

http.get '/пользовательские_данные_для_страницы', (ввод, вывод) ->
	if ввод.session?
		цепь(вывод)
			.сделать ->
				пользовательское.пользователь(ввод, @.в 'пользователь')
				
			.сделать ->
				db('people_sessions').findOne({ пользователь: @.$.пользователь._id }, @)
				
			.сделать (session) ->
				@.$.session = { настройки: session.настройки }
				
				@.$.пользователь = пользовательское.поля(['...', 'photo_version', 'полномочия'], @.$.пользователь)
				@.$.пользователь.беседы = {}
				@.$.пользователь.обсуждения = {}
				@.$.пользователь.новости = {}
				
				вывод.send(@.$)
				
	else
		if ввод.cookies.user?
			вывод.clearCookie 'user'
		вывод.send(ошибка: 'Пользователь не найден')
		
http.put '/сеть/человек/данные', (ввод, вывод, пользователь) ->
	цепь(вывод)
		.сделать ->
			db('people').update({ _id: пользователь._id }, { $set: { имя: ввод.body.имя, описание: ввод.body.описание, откуда: ввод.body.откуда } }, @)
			
		.сделать ->
			вывод.send {}
			
			if (ввод.body.имя != пользователь.имя)
				эфир.отправить('пользователь', 'смена имени', ввод.body.имя, { кому: пользователь._id })
			
http.put '/сеть/человек/картинка', (ввод, вывод, пользователь) ->
	имя = ввод.body.имя.to_unix_file_name()
	
	путь = Options.Upload_server.Temporary_file_path + '/' + имя + '.jpg'
	место = null

	цепь(вывод)
		.сделать ->
			место = Options.Upload_server.File_path + '/люди/' + пользователь['адресное имя'].to_unix_file_name() + '/картинка'
			снасти.создать_путь(место, @)
			
		.сделать ->			
			square_resize(путь, место + '/маленькая.jpg', Options.User.Picture.Chat.Size, @)
			
		.сделать ->
			снасти.переместить_и_переименовать(путь, { место: место, имя: 'большая.jpg' }, @)
			
		.сделать ->
			db('people').update({ _id: пользователь._id }, { $inc: { 'avatar_version': 1 } }, @)
			
		.сделать ->
			db('people').findOne({ _id: пользователь._id }, @)
			
		.сделать (пользователь) ->
			эфир.отправить('пользователь', 'аватар обновлён', { version: пользователь.avatar_version }, { кому: пользователь._id })
			вывод.send {}

http.get '/сеть/пользователь/настройки', (ввод, вывод, пользователь) ->
	цепь(вывод)
		.сделать ->
			пользовательское.пользователь_полностью(ввод, @._.в 'пользователь')
			
#		.сделать ->
#			db('people_sessions').findOne({ пользователь: пользователь._id }, @._.в 'session')
			
		.сделать (пользователь) ->
			настройки = {}
			
			if (пользователь.почта)
				настройки.почта = пользователь.почта
			
			if пользователь.настройки
				настройки.настройки = пользователь.настройки
				
			#настройки.Клавиши = @._.session.настройки.Клавиши
				
			вывод.send настройки

http.post '/сеть/пользователь/настройки', (ввод, вывод, пользователь) ->
	клавиши = JSON.parse(ввод.body.клавиши)
	
	цепь(вывод)
		.сделать ->
			пользовательское.пользователь_полностью(ввод, @._.в 'пользователь')
			
		.сделать (пользователь) ->
			@._.почта_изменилась = (пользователь.почта != ввод.body.почта)
			
			@._.новые_данные_пользователя = {}
			
			if (ввод.body.почта)
				@._.новые_данные_пользователя.почта = ввод.body.почта
				
			db('people').update({ _id: @._.пользователь._id }, { $set: @._.новые_данные_пользователя }, @)
			
		.сделать ->
			db('people_sessions').update({ _id: @._.пользователь._id }, { $set: { настройки: { клавиши: клавиши } } }, @)
			
		.сделать ->
			if @._.почта_изменилась
				почта.письмо(кому: @._.пользователь.имя + ' <' + @._.пользователь.почта + '>', тема: 'Проверка вашего нового почтового ящика', сообщение: 'Теперь это ваш почтовый ящик в нашей сети')
				
			эфир.отправить("пользователь", "настройки.клавиши", { клавиши: клавиши }, { кому: @._.пользователь._id })
				
			вывод.send {}

http.get '/сеть/мусорка', (ввод, вывод, пользователь) ->
	цепь(вывод)
		.сделать ->
			db('trash').find({ пользователь: пользователь._id }).toArray(@)
			
		.сделать (содержимое) ->
			вывод.send { содержимое: содержимое }
			
###
connect_utilities = require('connect').utils
http_proxy = require 'http-proxy'

http.post '/человек/сменить картинку', (ввод, вывод) ->
	приостановленный_ввод = connect_utilities.pause(ввод)
	return if пользовательское.требуется_вход(ввод, вывод)
	proxy = new http_proxy.RoutingProxy()
	proxy.proxyRequest(ввод, вывод,
		host: 'localhost'
		port: global.Upload_server_port
	)
	приостановленный_ввод.resume()
###