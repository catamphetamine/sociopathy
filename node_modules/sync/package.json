{
  "name": "sync",
  "description": "Library that makes simple to run asynchronous functions in synchronous manner, using node-fibers.",
  "version": "0.2.1",
  "url": "http://github.com/0ctave/node-sync",
  "author": {
    "name": "Yuriy Bogdanov",
    "email": "chinsay@gmail.com"
  },
  "main": "lib/sync",
  "engines": {
    "node": ">=0.5.2"
  },
  "dependencies": {
    "fibers": ">=0.6"
  },
  "readme": "# Introduction\nnode-sync is a simple library that allows you to call any asynchronous function in synchronous way. The main benefit is that it uses javascript-native design - Function.prototype.sync function, instead of heavy APIs which you'll need to learn. Also, asynchronous function which was called synchronously through node-sync doesn't blocks the whole process - it blocks only current thread!\n\nIt built on [node-fibers](https://github.com/laverdet/node-fibers) library as a multithreading solution.\n\nYou may also like [fibers-promise](https://github.com/lm1/node-fibers-promise) and [node-fiberize](https://github.com/lm1/node-fiberize) libraries.\n\n# Examples\nSimply call asynchronous function synchronously:\n\n```javascript\nvar Sync = require('sync');\n\nfunction asyncFunction(a, b, callback) {\n\tprocess.nextTick(function(){\n\t\tcallback(null, a + b);\n\t})\n}\n\n// Run in a fiber\nSync(function(){\n\t\n\t// Function.prototype.sync() interface is same as Function.prototype.call() - first argument is 'this' context\n\tvar result = asyncFunction.sync(null, 2, 3);\n\tconsole.log(result); // 5\n\n\t// Read file synchronously without blocking whole process? no problem\n\tvar source = require('fs').readFile.sync(null, __filename);\n    console.log(String(source)); // prints the source of this example itself\n})\n```\n\nIt throws exceptions!\n\n```javascript\nvar Sync = require('sync');\n\nfunction asyncFunction(a, b, callback) {\n\tprocess.nextTick(function(){\n\t\tcallback('something went wrong');\n\t})\n}\n\n// Run in a fiber\nSync(function(){\n\n\ttry {\n\t\tvar result = asyncFunction.sync(null, 2, 3);\n\t}\n\tcatch (e) {\n\t\tconsole.error(e); // something went wrong\n\t}\n})\n\n// Or simply specify callback function for Sync fiber\n// handy when you use Sync in asynchronous environment\nSync(function(){\n\t\n\t// The result will be passed to a Sync callback\n\tvar result = asyncFunction.sync(null, 2, 3);\n\treturn result;\n\t\n}, function(err, result){ // <-- standard callback\n\t\n\tif (err) console.error(err); // something went wrong\n\t\n\t// The result which was returned from Sync body function\n\tconsole.log(result);\n})\n```\n\nTransparent integration\n\n```javascript\nvar Sync = require('sync');\n\nvar MyNewFunctionThatUsesFibers = function(a, b) { // <-- no callback here\n\t\n\t// we can use yield here\n\t// yield();\n\t\n\t// or throw an exception!\n\t// throw new Error('something went wrong');\n\t\n\t// or even sleep\n\t// Sync.sleep(200);\n\t\n\t// or turn fs.readFile to non-blocking synchronous function\n\t// var source = require('fs').readFile.sync(null, __filename)\n\t\n\treturn a + b; // just return a value\n\t\n}.async() // <-- here we make this function friendly with async environment\n\n// Classic asynchronous nodejs environment\nvar MyOldFashoinAppFunction = function() {\n\t\n\t// We just use our MyNewFunctionThatUsesFibers normally, in a callback-driven way\n\tMyNewFunctionThatUsesFibers(2, 3, function(err, result){\n\t\t\n\t\t// If MyNewFunctionThatUsesFibers will throw an exception, it will go here\n\t\tif (err) return console.error(err);\n\t\t\n\t\t// 'return' value of MyNewFunctionThatUsesFibers\n\t\tconsole.log(result); // 5\n\t})\n}\n\n// From fiber environment\nSync(function(){\n\t\n\t// Run MyNewFunctionThatUsesFibers synchronously\n\tvar result = MyNewFunctionThatUsesFibers(2, 3);\n\tconsole.log(result); // 5\n\t\n\t// Or use sync() for it (same behavior)\n\tvar result = MyNewFunctionThatUsesFibers.sync(null, 2, 3);\n\tconsole.log(result); // 5\n})\n```\n\nParallel execution:\n\n```javascript\nvar Sync = require('sync'),\n\tFuture = Sync.Future();\n\n// Run in a fiber\nSync(function(){\n\ttry {\n\t\t// Three function calls in parallel\n\t\tvar foo = asyncFunction.future(null, 2, 3);\n\t\tvar bar = asyncFunction.future(null, 5, 5);\n\t\tvar baz = asyncFunction.future(null, 10, 10);\n\t\n\t\t// We are immediately here, no blocking\n\t\n\t\t// foo, bar, baz - our tickets to the future!\n\t    console.log(foo); // { [Function: Future] result: [Getter], error: [Getter] }\n\t\n\t\t// Get the results\n\t\t// (when you touch 'result' getter, it blocks until result would be returned)\n\t\tconsole.log(foo.result, bar.result, baz.result); // 5 10 20\n\t\n\t\t// Or you can straightly use Sync.Future without wrapper\n\t\t// This call doesn't blocks\n\t\tasyncFunction(2, 3, foo = Future());\n\t\n\t\t// foo is a ticket\n\t    console.log(foo); // { [Function: Future] result: [Getter], error: [Getter] }\n\n\t\t// Wait for the result\n\t\tconsole.log(foo.result); // 5\n\t}\n\tcatch (e) {\n\t\t// If some of async functions returned an error to a callback\n\t\t// it will be thrown as exception\n\t\tconsole.error(e);\n\t}\n})\n```\n\t\nTimeouts support\n\n```javascript\t\nvar Sync = require('sync'),\n\tFuture = Sync.Future;\n\nfunction asyncFunction(a, b, callback) {\n\tsetTimeout(function(){\n\t\tcallback(null, a + b);\n\t}, 1000)\n}\n\n// Run in a fiber\nSync(function(){\n\t\n\t// asyncFunction returns the result after 1000 ms\n\tvar foo = asyncFunction.future(null, 2, 3);\n\t// but we can wait only 500ms!\n\tfoo.timeout = 500;\n\n\ttry {\n\t    var result = foo.result;\n\t}\n\tcatch (e) {\n\t    console.error(e); // Future function timed out at 500 ms\n\t}\n\n\t// Same example with straight future function\n\tasyncFunction(2, 3, foo = new Future(500));\n\n\ttry {\n\t    var result = foo.result;\n\t}\n\tcatch (e) {\n\t    console.error(e); // Future function timed out at 500 ms\n\t}\n})\n```\n\t\nSee more examples in [examples](https://github.com/0ctave/node-sync/tree/master/examples) directory.\n\n# Installation\ninstall\n\n```bash\n$ npm install sync\n```\nand then\n\n```bash\n$ node your_file_using_sync.js\n```",
  "_id": "sync@0.2.1",
  "_from": "sync"
}
